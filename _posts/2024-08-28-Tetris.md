---
title: Tetris Game
output:
  md_document:
    variant: gfm+footnotes
    preserve_yaml: TRUE
date: 2024-08-28
permalink: /posts/2024-08-28-Tetris
excerpt_separator: <!--more-->
toc: false
tags:
  - game
  - tetris
---

Play Tetris and have fun! 

<!--more-->

<div class="tetris-container">
    <canvas id="tetris" width="240" height="400"></canvas>
    <div id="game-over">Game Over</div>
    <button id="start-button">Start Game</button>
</div>

<style>
    body {
        background-color: white;
        color: black;
        font-family: 'Arial', sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
    }
    .tetris-container {
        border: 2px solid #000;
        padding: 10px;
        text-align: center;
        background-color: #fff;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }
    canvas {
        border: 2px solid #000;
        background-color: #111;
    }
    #game-over {
        display: none;
        font-size: 24px;
        color: red;
    }
    #start-button {
        margin-top: 10px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
    }
</style>

<script>
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');
    const grid = 20;
    const rows = canvas.height / grid;
    const cols = canvas.width / grid;

    let board = Array.from({ length: rows }, () => Array(cols).fill(0));
    let currentPiece;
    let gameOver = false;
    let gameInterval;

    const pieces = [
        [[1, 1, 1, 1]], // I
        [[1, 1], [1, 1]], // O
        [[0, 1, 1], [1, 1, 0]], // S
        [[1, 1, 0], [0, 1, 1]], // Z
        [[1, 0, 0], [1, 1, 1]], // L
        [[0, 0, 1], [1, 1, 1]], // J
        [[0, 1, 0], [1, 1, 1]]  // T
    ];

    function drawBoard() {
        context.clearRect(0, 0, canvas.width, canvas.height);
        board.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    context.fillStyle = 'white';
                    context.fillRect(x * grid, y * grid, grid - 1, grid - 1);
                }
            });
        });
    }

    function drawPiece() {
        currentPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    context.fillStyle = 'white';
                    context.fillRect((currentPiece.x + x) * grid, (currentPiece.y + y) * grid, grid - 1, grid - 1);
                }
            });
        });
    }

    function collide() {
        return currentPiece.shape.some((row, y) =>
            row.some((value, x) => value && (board[currentPiece.y + y] && board[currentPiece.y + y][currentPiece.x + x]) !== 0)
        );
    }

    function merge() {
        currentPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    board[currentPiece.y + y][currentPiece.x + x] = 1;
                }
            });
        });
    }

    function rotatePiece() {
        const originalShape = currentPiece.shape;
        currentPiece.shape = currentPiece.shape[0].map((val, index) =>
            currentPiece.shape.map(row => row[index]).reverse()
        );
        if (collide()) {
            currentPiece.shape = originalShape; // revert if collision
        }
    }

    function resetGame() {
        board = Array.from({ length: rows }, () => Array(cols).fill(0));
        gameOver = false;
        document.getElementById('game-over').style.display = 'none';
        spawnPiece();
        drawBoard();
        drawPiece();
        update();
    }

    function spawnPiece() {
        const randomIndex = Math.floor(Math.random() * pieces.length);
        currentPiece = {
            shape: pieces[randomIndex],
            x: Math.floor(cols / 2) - 1,
            y: 0
        };
        if (collide()) {
            gameOver = true;
            document.getElementById('game-over').style.display = 'block';
            clearInterval(gameInterval);
        }
    }

    function removeFullLines() {
        board = board.reduce((acc, row) => {
            if (row.every(value => value !== 0)) {
                acc.unshift(Array(cols).fill(0)); // Add a new empty row at the top
            } else {
                acc.push(row); // Keep the current row
            }
            return acc;
        }, []);
    }

    function update() {
        if (gameOver) return;

        currentPiece.y++;
        if (collide()) {
            currentPiece.y--;
            merge();
            removeFullLines(); // Check for and remove full lines
            spawnPiece();
        }

        drawBoard();
        drawPiece();
    }

    document.addEventListener('keydown', (event) => {
        if (gameOver) return;
        if (event.key === 'ArrowLeft') {
            currentPiece.x--;
            if (collide()) currentPiece.x++;
        } else if (event.key === 'ArrowRight') {
            currentPiece.x++;
            if (collide()) currentPiece.x--;
        } else if (event.key === 'ArrowDown') {
            currentPiece.y++;
            if (collide()) {
                currentPiece.y--;
                merge();
                removeFullLines(); // Check for and remove full lines
                spawnPiece();
            }
        } else if (event.key === 'ArrowUp') {
            rotatePiece();
        }
        drawBoard();
        drawPiece();
    });

    document.getElementById('start-button').addEventListener('click', () => {
        resetGame();
        gameInterval = setInterval(update, 1000);
    });
</script>